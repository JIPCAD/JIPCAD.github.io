"use strict";(self.webpackChunkjipcad=self.webpackChunkjipcad||[]).push([[17],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),f=a,h=u["".concat(l,".").concat(f)]||u[f]||d[f]||i;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7590:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={sidebar_position:5},l="Geometric Manipulation",c={unversionedId:"lang-ref/manipulation",id:"lang-ref/manipulation",isDocsHomePage:!1,title:"Geometric Manipulation",description:"Sweeps",source:"@site/docs/lang-ref/manipulation.md",sourceDirName:"lang-ref",slug:"/lang-ref/manipulation",permalink:"/docs/lang-ref/manipulation",editUrl:"https://github.com/JIPCAD/NOME3/docs/lang-ref/manipulation.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Rendering Specifications",permalink:"/docs/lang-ref/rendering"},next:{title:"Q&A",permalink:"/docs/Q&A"}},p=[{value:"Sweeps",id:"sweeps",children:[],level:2},{value:"Group",id:"group",children:[],level:2},{value:"Subdivision",id:"subdivision",children:[],level:2},{value:"Offset",id:"offset",children:[],level:2}],d={toc:p};function u(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"geometric-manipulation"},"Geometric Manipulation"),(0,i.kt)("h2",{id:"sweeps"},"Sweeps"),(0,i.kt)("p",null,"A sweep describes the result of sweeping a crosssection along a path. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"sweep id  \n  crosssection id [reverse] [begincap] [endcap]  endcrosssection\n  path  id [mintorsion] [azimuth a_angle] [twist t_angle]  endpath\n  [brep brep-type]\nendsweep\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a crosssection - can be a polyline, circle, beziercurve, or bspline."),(0,i.kt)("li",{parentName:"ul"},"\u201creverse\u201d:  if present, flips the orientation of the crosssection, turning the generated brep-surface inside out."),(0,i.kt)("li",{parentName:"ul"},"\u201cbegincap\u201d:  if present, draw the starting face (with outward normal)."),(0,i.kt)("li",{parentName:"ul"},"\u201cendcap\u201d:  if present, draw the ending face (with outward normal"),(0,i.kt)("li",{parentName:"ul"},"a path - can be a polyline, circle, beziercurve, or bspline."),(0,i.kt)("li",{parentName:"ul"},"Each path has a set of Frenet frames (tangents, normals, & binormals) that are used to determine how the crosssectiwill twist along the path. The user can control the twist in four ways and these options are additive in the order givbelow:"),(0,i.kt)("li",{parentName:"ul"},"1) mintorsion - minimizes the twisting of the intrinsic Frenet frame."),(0,i.kt)("li",{parentName:"ul"},"2) azimuth - angle about the tangent that all Frenet frames will be rotated by."),(0,i.kt)("li",{parentName:"ul"},"3) twist - angle about the tangent that specifies the overall amount of twist from the first Frenet frame to the last."),(0,i.kt)("li",{parentName:"ul"},"4) warp - sets each twist angle explicitly at specified controlpoints in the path."),(0,i.kt)("li",{parentName:"ul"},"These controlpoints also permit rotating and non-uniformly scaling of the crosssection at these locations.  Regular papoints act like control points with no additional transformations.  At any sample points between adjacent controlpointthe transformation variables are interpolated in the same way that the x, y, and z-coordinates are being interpolated g. by a cubic polynomial for the cubic Bspline"),(0,i.kt)("li",{parentName:"ul"},"brep_type - can be either TRIANGLES (=default) or QUADRILATERALS.")),(0,i.kt)("p",null,"Scene Graph\nInstance\ninstance name object ","[rotate (rx ry rz){in degrees} ][scale (sx sy sz)]","   ","[translate (tx ty tz)][surface surface_id]"," ","[LOD LOD_type][shading shading_type]"," endinstance\nCreates an instance of geometry. One can optionally rotate, scale, translate the instance and specify its color, level-of-detail (LOD), and rendering mode."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"object: the name of the primitive, generator, or group that will be instantiated."),(0,i.kt)("li",{parentName:"ul"},"surface_id: a specified (RGB) surface color."),(0,i.kt)("li",{parentName:"ul"},"LOD_type: defined types: \u201cNOME_OFF\u201d {not rendered}; NOME_BOUND\u201d {render only the bounding box of this subtree}; \u201cNOME_EDGES\u201d {render this subtree in wireframe mode};  \u201cNOME_FULL\u201d {fully render this subtree)."),(0,i.kt)("li",{parentName:"ul"},"shading_type: defined types: \u201cNOME_INHERIT\u201d {Shade this node in the same style as its parent};   \u201cNOME_WIRE\u201d {renderas a wireframe};  \u201cNOME_FLAT\u201d {render with flat shading: one color per polygon};  \u201cNOME_GOURAUD\u201d render with Gouraudshading: interpolate vertex colors across each polygon};   \u201cNOME_PHONG\u201d {render with Phong shading:  interpolate vertexnormals across each polygon and recompute lighting at each pixel}.")),(0,i.kt)("h2",{id:"group"},"Group"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"group id\n   instance id1 object_id1 [instance_parameters] endinstance\n   ...\n   instance idN object_idN [instance_parameters] endinstance\nendgroup\n")),(0,i.kt)("p",null,"Defines a collection of instances of primitive objects or other groups. Groups are the most general construct to introduce hierarchy into a model description."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"id: the name of the instance."),(0,i.kt)("li",{parentName:"ul"},"object_id: the name of the object to be instantiated."),(0,i.kt)("li",{parentName:"ul"},"[instance_parameters]",": all the optional parameters discussed above.")),(0,i.kt)("h2",{id:"subdivision"},"Subdivision"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"subdivision id\n        [sd_type sd_flag]\nsd_level\ninstance id1 object_id1 [xform & color] endinstance\n   ...\n   instance idN object_idN [xform & color] endinstance\nendsubdivision\n")),(0,i.kt)("p",null,"Subdivides a merged mesh into smaller facets.."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"sd_flag: the type of subdivision algorithm used."),(0,i.kt)("li",{parentName:"ul"},"NOME_SD_CatmullClark:  the plain and simple CC subdivision"),(0,i.kt)("li",{parentName:"ul"},"NOME_SD_CC_sharp:  CC subdivision respecting \u201csharp\u201d flags in the mesh."),(0,i.kt)("li",{parentName:"ul"},"sd_level: the integer number of iterated subdivision steps."),(0,i.kt)("li",{parentName:"ul"},"[xform & color]",": the optional parameters relating to transformations and coloring.")),(0,i.kt)("h2",{id:"offset"},"Offset"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"offset id\n        [offset_type offset_flag]\nheight\nwidth\ninstance id1 object_id1 [xform & color] endinstance\n   ...\n   instance idN object_idN [xform & color] endinstance\nendoffset\n")),(0,i.kt)("p",null,"Offset thickens a surface mesh of zero thickness into a thicker B-rep that can be 3D-printed"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"offset_flag: the type of thickened surface generated:"),(0,i.kt)("li",{parentName:"ul"},"NOME_OFFSET_DEFAULT: This offsets the starting mesh inward and outward symmetrically.  Each facet in the originalmesh maps to two facets in the offset mesh; one of them with reversed orientation.  Each boundary edge of an openpolyhedron will map to a quadrilateral facet."),(0,i.kt)("li",{parentName:"ul"},"NOME_OFFSET_GRID: The edges of the starting mesh are viewed as thin wires which are then thickened into 4-sided prismsegments. This is different from \u201cgridding\u201d the original mesh, where the openings in each facet are a given fraction ofthe facet geometry."),(0,i.kt)("li",{parentName:"ul"},"height: the half-thickness of the generated surface normal to the original facets."),(0,i.kt)("li",{parentName:"ul"},"width:  the width of the prismatic beams in the tangential direction of each facet."),(0,i.kt)("li",{parentName:"ul"},"[xform & color]",":  the optional parameters relating to transformations and coloring.")))}u.isMDXComponent=!0}}]);