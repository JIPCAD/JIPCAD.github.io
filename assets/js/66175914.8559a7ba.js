"use strict";(self.webpackChunkjipcad=self.webpackChunkjipcad||[]).push([[5201],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var l=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);n&&(l=l.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,l)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,l,a=function(e,n){if(null==e)return{};var t,l,a={},i=Object.keys(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(l=0;l<i.length;l++)t=i[l],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=l.createContext({}),p=function(e){var n=l.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=p(e.components);return l.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return l.createElement(l.Fragment,{},n)}},h=l.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),h=a,g=d["".concat(s,".").concat(h)]||d[h]||u[h]||i;return t?l.createElement(g,r(r({ref:n},c),{},{components:t})):l.createElement(g,r({ref:n},c))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=h;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:a,r[1]=o;for(var p=2;p<i;p++)r[p]=t[p];return l.createElement.apply(null,r)}return l.createElement.apply(null,t)}h.displayName="MDXCreateElement"},8121:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var l=t(7462),a=(t(7294),t(3905));const i={sidebar_position:3},r="Putting It All Together",o={unversionedId:"tutorial/putting-together",id:"tutorial/putting-together",title:"Putting It All Together",description:"This is an advanced tutorial which assumes you are familiar with most/all commands in JIPCAD and want to stretch your abilities with a challenging test model. To that end, most implementation details will be hidden; the visible section of the dropdown will give you a hint to get started, while revealing the bottom section will provide the germane code.",source:"@site/docs/tutorial/putting-together.md",sourceDirName:"tutorial",slug:"/tutorial/putting-together",permalink:"/docs/tutorial/putting-together",draft:!1,editUrl:"https://github.com/JIPCAD/JIPCAD/docs/tutorial/putting-together.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Basic Shapes",permalink:"/docs/tutorial/basic-shapes"},next:{title:"Developer Guide",permalink:"/docs/tutorial/developer"}},s={},p=[{value:"Yoke",id:"yoke",level:2},{value:"Bell",id:"bell",level:2},{value:"Clapper",id:"clapper",level:2},{value:"Clapper Movement",id:"clapper-movement",level:2},{value:"Building Lightning",id:"building-lightning",level:2},{value:"Lightning Behavior",id:"lightning-behavior",level:2},{value:"Accoutrements",id:"accoutrements",level:2}],c={toc:p},d="wrapper";function u(e){let{components:n,...i}=e;return(0,a.kt)(d,(0,l.Z)({},c,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"putting-it-all-together"},"Putting It All Together"),(0,a.kt)("p",null,"This is an advanced tutorial which assumes you are familiar with most/all commands in JIPCAD and want to stretch your abilities with a challenging test model. To that end, most implementation details will be hidden; the visible section of the dropdown will give you a hint to get started, while revealing the bottom section will provide the germane code."),(0,a.kt)("p",null,"We will be making a bell whose clapper swings back and forth, causing lightning to strike outwards whenever it hits the bell's edge."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"bell-side",src:t(731).Z,width:"744",height:"727"})),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"bell-lightning",src:t(1164).Z,width:"902",height:"637"})),(0,a.kt)("p",null,"As an added challenge, the code provided corresponds to the images above, where the yoke lies parallel to the arc of the clapper. In reality, the yoke should lie perpendicular to the clapper, allowing the bell to swing in response to the impact and cause noise. See if you can implement this for yourself."),(0,a.kt)("h2",{id:"yoke"},"Yoke"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"The yoke is three rectangles, one thinner rectangle lying horizontal and intersecting the two thicker, vertical rectangles towards their tops. The two vertical rectangles lie at the same elevation. The rectangles are colored with Orange, Zinc, and Brown from the Surfaces file in Common Include Files so that top and bottom are orange, front and back are brown, and left and right are zinc."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"##############YOKE###############\n\npoint sq1 (-1 1 0) endpoint\npoint sq2 (-1 -1 0) endpoint\npoint sq3 (1 -1 0) endpoint\npoint sq4 (1 1 0) endpoint\n\nmesh cube\nface side (sq1 sq2 sq3 sq4 sq1) endface\nendmesh\n\ngroup halfCube\ninstance sCube cube  rotate (1 0 0) (180) endinstance\ninstance lid cube translate (0 0 2) endinstance\ninstance leftSide cube rotate (1 0 0) (90) translate (0 -1 1) surface O endinstance\nendgroup\n\ngroup fullCube\ninstance sHalfCube halfCube rotate (1 0 1) (180) translate (-1 0 1) surface ZC endinstance\ninstance otherHalf halfCube surface BR endinstance\nendgroup\n\ngroup rotateYoke\ninstance topYoke fullCube scale(6 1 1/2) translate(0 1/2 -1/2) rotate(1 0 0) (-90) endinstance\ninstance leftYoke fullCube scale(1 3 1) translate (-4 -1 -1) rotate(1 0 0) (-90) endinstance\ninstance rightYoke fullCube scale(1 3 1) translate (4 -1 -1) rotate(1 0 0) (-90)  endinstance\nendgroup\n\ninstance sRotateYoke rotateYoke rotate(0 0 1) (-90) endinstance\n"))),(0,a.kt)("h2",{id:"bell"},"Bell"),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"The top portion of the bell is an implicit paraboloid, the bottom curve is an implicit hyperboloid, the bottom ring is a torus, and the small cap at the top is a simple cylinder. They are all grey, and fit under the yoke so that a small portion of the bell intersects with all three inner faces of the yoke.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"############BELL##############\n\ngenimplicitsurf LibBell func [-(z^2)+((1.25x)^2)+((1.25y)^2)-20] (-10 10 -10 10 0 10  30 30 30) endgenimplicitsurf\ninstance sBellCup LibBell translate (0 0 3) surface GR endinstance\n\ngenimplicitsurf bellTop func [-z+((x/sqrt(4.25))^2)+((y/sqrt(4.25))^2)] (-10 10 -10 10 -3 3 30 30 30) endgenimplicitsurf\ninstance sBellTop bellTop surface GR endinstance\n\ntorus bellLip (8.57904423581 (8.94427191-8.57904423581)*2 360 0 360 30 30) endtorus\ninstance sBellLip bellLip translate (0 0 13 ) surface GR endinstance\n\ncylinder topCapper (0.75 0.55 360 30 botcap topcap) endcylinder\ninstance sTopCapper topCapper surface GR endinstance\n"))),(0,a.kt)("h2",{id:"clapper"},"Clapper"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"The clapper is a cylinder with a ball on the end. At the clapper's top, it should connect with the bottom of the bell's cap, while the clapper's bottom should extend below the torus of the bell."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"##############STRIKING CYLINDER#########\n\ncylinder clapperStalk (0.75 15 360 30 botcap topcap) endcylinder\ninstance sClapperStalk clapperStalk translate(0 0 0.5) rotate(? ? ?) (?) surface GR endinstance\n\nsphere clapperEnd (1.25 360 -90 90 30 30) endsphere\ninstance sClapperEnd clapperEnd translate(0 0 15.5) rotate(? ? ?) (?) surface GR endinstance\n"))),(0,a.kt)("h2",{id:"clapper-movement"},"Clapper Movement"),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"The clapper should constantly swing along one axis--preferrably perpendicular to the yoke--along a pendulum arc, i.e. slow at the end of the swing, fast in the middle. The clapper should strike the bell at the apex of its swing but should not poke through any part of the bell.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"##############STRIKING CYLINDER#########\n\ncylinder clapperStalk (0.75 15 360 30 botcap topcap) endcylinder\ninstance sClapperStalk clapperStalk translate(0 0 0.5) rotate(1 0 0) (27.5*cos($time)) surface GR endinstance\n\nsphere clapperEnd (1.25 360 -90 90 30 30) endsphere\ninstance sClapperEnd clapperEnd translate(0 0 15.5) rotate(1 0 0) (27.5*cos($time)) surface GR endinstance\n"))),(0,a.kt)("h2",{id:"building-lightning"},"Building Lightning"),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"We want two lightning bolts, one on either side of the bell at the position where clapper strikes the torus, pointing straight outwards. Lightning bolts should be thin at the tips and thin at the middle. Any construction or design will do; the code provided uses a Sweep Morph. Lightning bolts are yellow.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"#############LIGHTNING BOLTS############\n\npoint lb1 (5 0 0) endpoint\npoint lb2 (-5 0 0) endpoint\npoint lb3 (0 1 0) endpoint\npoint lb4 (0 -1 0) endpoint\n\ncircle circ (1 {expr par.boltSegs}) endcircle\n\ncontrolpoint clb1  point lb1  scale (0.05 0.05 0.05) rotate (0 0 0) crosssection circ endcontrolpoint\ncontrolpoint clb2 point lb2 scale(0.05 0.05 0.05) endcontrolpoint\ncontrolpoint clb3 point lb3 scale(0.65 0.5 0.5) endcontrolpoint\ncontrolpoint clb4 point lb4 scale(0.65 0.5 0.5)  endcontrolpoint\n\npolyline lightning (clb2 clb4 clb3 clb1) endpolyline\n\nsweepmorph lightningBolt \n    begincap endcap\n    path  lightning mintorsion azimuth 0 twist 0  endpath\nendsweepmorph\n\ngroup oneLB\ninstance sLightningBolt lightningBolt rotate(0 0 1) (90) scale(? ? ?) translate (0 -15 13) surface Y  endinstance\nendgroup\n\ngroup flippedLB\ninstance sLightningBolt lightningBolt rotate(0 0 1) (90) scale(? ? ?) rotate(1 0 0) (180) translate (0 15 13) surface Y  endinstance\nendgroup\n\n#Negative Y (left-hand) bolt\ninstance lLB1 oneLB  endinstance\n\n#Positive Y (right-hand) bolt\ninstance rLB1 flippedLB  endinstance\n"))),(0,a.kt)("h2",{id:"lightning-behavior"},"Lightning Behavior"),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"We want the lightning bolt to very rapidly expand to full size when the clapper nears (and then strikes) the bell, and to shrink to an infintesimally small point when the clapper moves backwards. Hint: what kind of function mimics the movement of the clapper? The blog post on Striking Bell gives nearly the whole answer if you get stuck.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"group oneLB\ninstance sLightningBolt lightningBolt rotate(0 0 1) (90) scale(cos(($time)/2)^128 cos(($time)/2)^128 1) translate (0 -15 13) surface Y  endinstance\nendgroup\n\ngroup flippedLB\ninstance sLightningBolt lightningBolt rotate(0 0 1) (90) scale(sin(($time)/2)^128 sin(($time)/2)^128 1) rotate(1 0 0) (180) translate (0 15 13) surface Y  endinstance\nendgroup\n"))),(0,a.kt)("h2",{id:"accoutrements"},"Accoutrements"),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"Add a speed parameter which makes the clapper swing faster and similarly effects when the lightning bolts appear. Note this requires editing in several places.")),(0,a.kt)("p",null,"#1:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"bank par\nset speed 1 0 40 0.1\nset boltSegs 4 3 100 1\nlist(speed)\nendbank\n")),(0,a.kt)("p",null,"#2:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"instance sClapperStalk clapperStalk translate(0 0 0.5) rotate(1 0 0) (27.5*cos($time*{expr par.speed})) surface GR endinstance\n")),(0,a.kt)("p",null,"#3:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"instance sClapperEnd clapperEnd translate(0 0 15.5) rotate(1 0 0) (27.5*cos($time*{expr par.speed})) surface GR endinstance\n")),(0,a.kt)("p",null,"#4:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"instance sLightningBolt lightningBolt rotate(0 0 1) (90) scale(cos(($time*{expr par.speed})/2)^128 cos(($time*{expr par.speed})/2)^128 1) translate (0 -15 13) surface Y  endinstance\n")),(0,a.kt)("p",null,"#5:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"instance sLightningBolt lightningBolt rotate(0 0 1) (90) scale(sin(($time*{expr par.speed})/2)^128 sin(($time*{expr par.speed})/2)^128 1) rotate(1 0 0) (180) translate (0 15 13) surface Y  endinstance\n"))),(0,a.kt)("p",null,"Congratulations! Finishing this bell is no small task. The full code of the example is pasted in the dropdown below."),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"Full code for Striking Bell.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"include z_inclSurfaces.nom endinclude\n\nbank par\nset speed 1 0 40 0.1\nset boltSegs 4 3 100 1\nlist(speed)\nendbank\n\n##############YOKE###############\n\npoint sq1 (-1 1 0) endpoint\npoint sq2 (-1 -1 0) endpoint\npoint sq3 (1 -1 0) endpoint\npoint sq4 (1 1 0) endpoint\n\nmesh cube\nface side (sq1 sq2 sq3 sq4 sq1) endface\nendmesh\n\ngroup halfCube\ninstance sCube cube  rotate (1 0 0) (180) endinstance\ninstance lid cube translate (0 0 2) endinstance\ninstance leftSide cube rotate (1 0 0) (90) translate (0 -1 1) surface O endinstance\nendgroup\n\ngroup fullCube\ninstance sHalfCube halfCube rotate (1 0 1) (180) translate (-1 0 1) surface ZC endinstance\ninstance otherHalf halfCube surface BR endinstance\nendgroup\n\ngroup rotateYoke\ninstance topYoke fullCube scale(6 1 1/2) translate(0 1/2 -1/2) rotate(1 0 0) (-90) endinstance\ninstance leftYoke fullCube scale(1 3 1) translate (-4 -1 -1) rotate(1 0 0) (-90) endinstance\ninstance rightYoke fullCube scale(1 3 1) translate (4 -1 -1) rotate(1 0 0) (-90)  endinstance\nendgroup\n\ninstance sRotateYoke rotateYoke rotate(0 0 1) (-90) endinstance\n\n############BELL##############\n\ngenimplicitsurf LibBell func [-(z^2)+((1.25x)^2)+((1.25y)^2)-20] (-10 10 -10 10 0 10  30 30 30) endgenimplicitsurf\ninstance sBellCup LibBell translate (0 0 3) surface GR endinstance\n\ngenimplicitsurf bellTop func [-z+((x/sqrt(4.25))^2)+((y/sqrt(4.25))^2)] (-10 10 -10 10 -3 3 30 30 30) endgenimplicitsurf\ninstance sBellTop bellTop surface GR endinstance\n\ntorus bellLip (8.57904423581 (8.94427191-8.57904423581)*2 360 0 360 30 30) endtorus\ninstance sBellLip bellLip translate (0 0 13 ) surface GR endinstance\n\ncylinder topCapper (0.75 0.55 360 30 botcap topcap) endcylinder\ninstance sTopCapper topCapper surface GR endinstance\n\n##############STRIKING CYLINDER#########\n\ncylinder clapperStalk (0.75 15 360 30 botcap topcap) endcylinder\ninstance sClapperStalk clapperStalk translate(0 0 0.5) rotate(1 0 0) (27.5*cos($time*{expr par.speed})) surface GR endinstance\n\nsphere clapperEnd (1.25 360 -90 90 30 30) endsphere\ninstance sClapperEnd clapperEnd translate(0 0 15.5) rotate(1 0 0) (27.5*cos($time*{expr par.speed})) surface GR endinstance\n\n#############LIGHTNING BOLTS############\n\npoint lb1 (5 0 0) endpoint\npoint lb2 (-5 0 0) endpoint\npoint lb3 (0 1 0) endpoint\npoint lb4 (0 -1 0) endpoint\n\ncircle circ (1 {expr par.boltSegs}) endcircle\n\ncontrolpoint clb1  point lb1  scale (0.05 0.05 0.05) rotate (0 0 0) crosssection circ endcontrolpoint\ncontrolpoint clb2 point lb2 scale(0.05 0.05 0.05) endcontrolpoint\ncontrolpoint clb3 point lb3 scale(0.65 0.5 0.5) endcontrolpoint\ncontrolpoint clb4 point lb4 scale(0.65 0.5 0.5)  endcontrolpoint\n\npolyline lightning (clb2 clb4 clb3 clb1) endpolyline\n\nsweepmorph lightningBolt \n    begincap endcap\n    path  lightning mintorsion azimuth 0 twist 0  endpath\nendsweepmorph\n\ngroup oneLB\ninstance sLightningBolt lightningBolt rotate(0 0 1) (90) scale(cos(($time*{expr par.speed})/2)^128 cos(($time*{expr par.speed})/2)^128 1) translate (0 -15 13) surface Y  endinstance\nendgroup\n\ngroup flippedLB\ninstance sLightningBolt lightningBolt rotate(0 0 1) (90) scale(sin(($time*{expr par.speed})/2)^128 sin(($time*{expr par.speed})/2)^128 1) rotate(1 0 0) (180) translate (0 15 13) surface Y  endinstance\nendgroup\n\n#Negative Y (left-hand) group \ninstance lLB1 oneLB  endinstance\n\n#Positive Y (right-hand) group \ninstance rLB1 flippedLB  endinstance\n"))))}u.isMDXComponent=!0},1164:(e,n,t)=>{t.d(n,{Z:()=>l});const l=t.p+"assets/images/Bell-lightning-2bfb56be25ddacbf5ff62f82ec16b8ee.png"},731:(e,n,t)=>{t.d(n,{Z:()=>l});const l=t.p+"assets/images/bell-side-1fabecc88f46a481b23dae37548ef834.png"}}]);