"use strict";(self.webpackChunkjipcad=self.webpackChunkjipcad||[]).push([[526],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(n),c=i,h=d["".concat(s,".").concat(c)]||d[c]||m[c]||r;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6018:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return u},default:function(){return d}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={sidebar_position:3},s="Generators",p={unversionedId:"lang-ref/generators",id:"lang-ref/generators",isDocsHomePage:!1,title:"Generators",description:"Point (Status: Up-to-date)",source:"@site/docs/lang-ref/generators.md",sourceDirName:"lang-ref",slug:"/lang-ref/generators",permalink:"/docs/lang-ref/generators",editUrl:"https://github.com/JIPCAD/NOME3/docs/lang-ref/generators.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Numerical Parameters and Sliders",permalink:"/docs/lang-ref/numerical-sliders"},next:{title:"Rendering Specifications",permalink:"/docs/lang-ref/rendering"}},u=[{value:"<strong>Point</strong> <strong>(Status: Up-to-date)</strong>",id:"point-status-up-to-date",children:[],level:2},{value:"<strong>Controlpoint</strong>",id:"controlpoint",children:[],level:2},{value:"<strong>Polyline</strong> <strong>(Status: surface not implemented)</strong>",id:"polyline-status-surface-not-implemented",children:[],level:2},{value:"<strong>Face</strong> <strong>(Status: Up-to-date)</strong>",id:"face-status-up-to-date",children:[],level:2},{value:"<strong>Bezier Curve</strong> <strong>(Status: Up-to-date)</strong>",id:"bezier-curve-status-up-to-date",children:[],level:2},{value:"<strong>B-Spline</strong> <strong>(Status: Up-to-date)</strong>",id:"b-spline-status-up-to-date",children:[],level:2},{value:"<strong>Mesh</strong> <strong>(Status: Up-to-date)</strong>",id:"mesh-status-up-to-date",children:[],level:2},{value:"<strong>Circle</strong> <strong>(Status: Up-to-date)</strong>",id:"circle-status-up-to-date",children:[],level:2},{value:"Disk",id:"disk",children:[],level:2},{value:"<strong>Cylinder</strong>",id:"cylinder",children:[],level:2},{value:"<strong>Cone</strong> <strong>(this command is not implemented)</strong>",id:"cone-this-command-is-not-implemented",children:[],level:2},{value:"<strong>Funnel</strong>",id:"funnel",children:[],level:2},{value:"<strong>Tunnel</strong>",id:"tunnel",children:[],level:2},{value:"<strong>Sphere {older implementation}</strong>",id:"sphere-older-implementation",children:[],level:2},{value:"Sphere {current implementation}",id:"sphere-current-implementation",children:[],level:2},{value:"newSphere",id:"newsphere",children:[],level:2},{value:"Ellipsoid (Status: Up-to-date)",id:"ellipsoid-status-up-to-date",children:[],level:2},{value:"Torus (Status: Up-to-date)",id:"torus-status-up-to-date",children:[],level:2},{value:"Torus Knot (Status: Up-to-date)",id:"torus-knot-status-up-to-date",children:[],level:2},{value:"<strong>Mobius Strip</strong>  <strong>(Status: current implementation does not use thickness. uses radius, twists, cuts, and segs)</strong>",id:"mobius-strip--status-current-implementation-does-not-use-thickness-uses-radius-twists-cuts-and-segs",children:[],level:2},{value:"Dupin Cycle",id:"dupin-cycle",children:[],level:2},{value:"General Cartesian Surface",id:"general-cartesian-surface",children:[],level:2},{value:"General Parametric Surface",id:"general-parametric-surface",children:[],level:2},{value:"General Implicit Surface",id:"general-implicit-surface",children:[],level:2}],m={toc:u};function d(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"generators"},"Generators"),(0,r.kt)("h2",{id:"point-status-up-to-date"},(0,r.kt)("strong",{parentName:"h2"},"Point")," ",(0,r.kt)("strong",{parentName:"h2"},"(Status: Up-to-date)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"point id (x y z) endpoint\n")),(0,r.kt)("p",null,"Defines a point at the specified x, y, and z coordinates."),(0,r.kt)("h2",{id:"controlpoint"},(0,r.kt)("strong",{parentName:"h2"},"Controlpoint")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"controlpoint id  point id scale(sx sy sz) rotate(rx ry rz) endcontrolpoint\n")),(0,r.kt)("p",null,"Enhances a point (id) with additional parameters controlling the non-uniform scaling and rotation (rz) and tilting (rx, ry) of the cross section swept along a path."),(0,r.kt)("h2",{id:"polyline-status-surface-not-implemented"},(0,r.kt)("strong",{parentName:"h2"},"Polyline")," ",(0,r.kt)("strong",{parentName:"h2"},"(Status: surface not implemented)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"polyline id ( point_idlist ) [closed] [surface surface_id] endpolyline\n")),(0,r.kt)("p",null,"Defines a polyline, a chain of piecewise linear segments. You can optionally make it closed, i.e., the last point connects back to the first."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,r.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,r.kt)("inlineCode",{parentName:"li"},"point2")," ...")),(0,r.kt)("h2",{id:"face-status-up-to-date"},(0,r.kt)("strong",{parentName:"h2"},"Face")," ",(0,r.kt)("strong",{parentName:"h2"},"(Status: Up-to-date)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"face id (point_idlist) [surface surface_id] endface\n")),(0,r.kt)("p",null,"Defines a face from a list of points. Front face uses counter-clockwise winding."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,r.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,r.kt)("inlineCode",{parentName:"li"},"point2")," ...")),(0,r.kt)("h2",{id:"bezier-curve-status-up-to-date"},(0,r.kt)("strong",{parentName:"h2"},"Bezier Curve")," ",(0,r.kt)("strong",{parentName:"h2"},"(Status: Up-to-date)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"beziercurve id (point_idlist) segs  endbeziercurve\n")),(0,r.kt)("p",null,"Defines a Bezier curve."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,r.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,r.kt)("inlineCode",{parentName:"li"},"point2")," ..."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs"),": the number of segments into which the Bezier curve is sampled.")),(0,r.kt)("h2",{id:"b-spline-status-up-to-date"},(0,r.kt)("strong",{parentName:"h2"},"B-Spline")," ",(0,r.kt)("strong",{parentName:"h2"},"(Status: Up-to-date)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bspline id order (point_idlist) segs endbspline\n")),(0,r.kt)("p",null,"Defines a B-spline."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"{order}"),": integer that sets the B-spline's DEGREE to be ",(0,r.kt)("inlineCode",{parentName:"li"},"{order}-1"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,r.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,r.kt)("inlineCode",{parentName:"li"},"point2")," ..."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs"),": the number of segments into which the B-spline is sampled."),(0,r.kt)("li",{parentName:"ul"},"The number of control points must be greater than or equal to ",(0,r.kt)("inlineCode",{parentName:"li"},"{order}")),(0,r.kt)("li",{parentName:"ul"},"For closed curves, there must be at least ",(0,r.kt)("inlineCode",{parentName:"li"},"{order}-1")," control points.")),(0,r.kt)("h2",{id:"mesh-status-up-to-date"},(0,r.kt)("strong",{parentName:"h2"},"Mesh")," ",(0,r.kt)("strong",{parentName:"h2"},"(Status: Up-to-date)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mesh id \n    point pointId1 id1 (x y z) endpoint \n    \u2026\n    point pointIdN (x y z) endpoint\n    \n    face faceId1 ( point_idlist1 ) [surface surface_id] endface \n    ... \n    face faceIdN ( point_idlistN) [surface surface_id] endface\nendface endmesh\n")),(0,r.kt)("p",null,"Also creates a collection of faces, which can optionally be colored. Faces in a mesh can then be referred to in the rest of the program via a hierarchical name: id.faceId. Variable names must be unique within a mesh."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"faceId"),": the name of the face")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"point_idlist"),": a list of points of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"point1")," ",(0,r.kt)("inlineCode",{parentName:"p"},"point2")," ...")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"pointId"),": the name of the point"))),(0,r.kt)("h2",{id:"circle-status-up-to-date"},(0,r.kt)("strong",{parentName:"h2"},"Circle")," ",(0,r.kt)("strong",{parentName:"h2"},"(Status: Up-to-date)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"circle id (radius segs) endcircle\n")),(0,r.kt)("p",null,"Defines a circle."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),": the radius."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs"),": the number of line segments."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"segs")," :cannot be negative.")),(0,r.kt)("h2",{id:"disk"},"Disk"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Disk id (radius theta_max theta_segs) enddisk\n")),(0,r.kt)("p",null,"Defines a (partial) disk."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"radius"),": the radius of the disk.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"theta_max"),": the max theta angle (<= 360 degrees), resulting in a wedge.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"theta_segs"),": the number of segments in the wedge perimeter.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"radius"),",",(0,r.kt)("inlineCode",{parentName:"p"}," theta_segs")," cannot be negative.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Theta_max")," must be between 0 ~ 360 degrees."))),(0,r.kt)("h2",{id:"cylinder"},(0,r.kt)("strong",{parentName:"h2"},"Cylinder")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cylinder id (radius height theta_max theta_segs [botcap] [topcap] ) endcylinder\n")),(0,r.kt)("p",null,"Defines a (wedge of a) cylinder."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),": the radius at the bottom."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"height"),": the height of a complete cone."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"theta_max"),": the max theta angle (<= 360 degrees), resulting in a cylinder wedge."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"theta_segs"),": the number of segments in the theta direction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\u201cbotcap\u201d"),": if present, draw the bottom face (with downward normal)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\u201ctopcap\u201d"),": if present, draw the top face on the cylinder."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Radius"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"height"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"theta_segs")," cannot be negative."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Theta_max")," must be between 0 ~ 360 degrees.")),(0,r.kt)("h2",{id:"cone-this-command-is-not-implemented"},(0,r.kt)("strong",{parentName:"h2"},"Cone")," ",(0,r.kt)("strong",{parentName:"h2"},"(this command is not implemented)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cone id (radius height hgt_max theta_max theta_segs [botcap] [topcap] ) endcone\n")),(0,r.kt)("p",null,"Defines a (possibly truncated) cone."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),": the radius at the bottom."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"height"),": the height of a complete cone."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hgt_max"),": the fraction of the height ","[0, 1]"," at which the cone is truncated."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"theta_max"),": the max theta angle (<= 360 degrees), resulting in a partial cone."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"theta_segs"),": the number of segments in the theta direction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\u201cbotcap\u201d"),": if present, draw the bottom face (with downward normal)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"\u201ctopcap\u201d"),": if present, draw the top face on a truncated cone.2")),(0,r.kt)("h2",{id:"funnel"},(0,r.kt)("strong",{parentName:"h2"},"Funnel")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"funnel id (radius ratio height segs) endfunnel\n")),(0,r.kt)("p",null,"Defines a funnel, i.e. the mantle of a truncated cone."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),": the radius of the \u201cbottom\u201d ring."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ratio"),": the ratio of the radii of the top ring and the bottom ring."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"height"),": the height of the truncated cone."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs"),": the number of segments around the equator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ratio"),",",(0,r.kt)("inlineCode",{parentName:"li"}," height"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"segs")," cannot be negative.")),(0,r.kt)("h2",{id:"tunnel"},(0,r.kt)("strong",{parentName:"h2"},"Tunnel")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"tunnel id (radius ratio height segs) endtunnel\n")),(0,r.kt)("p",null,"Defines a tunnel made from two Funnels, glued bottom-to-bottom."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),": the radius of the \u201cmiddle\u201d ring."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ratio"),": the ratio of the radii of the two outer rings and the middle ring."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"height"),": the heights of each of the truncated cones."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs"),": the number of segments around the equator."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),",",(0,r.kt)("inlineCode",{parentName:"li"}," ratio"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"height"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"segs")," cannot be negative.")),(0,r.kt)("h2",{id:"sphere-older-implementation"},(0,r.kt)("strong",{parentName:"h2"},"Sphere {older implementation}")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sphere id (num_sides radius num_rotation max_theta min_phi max_phi) endsphere\n")),(0,r.kt)("p",null,"Defines a sphere."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"num_sides"),": the number of line segments in the latitudinal direction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius"),": the radius of the sphere"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"num_rotation"),": the number of line segments in the longitudinal direction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_theta"),": the max theta of any latitude, resulting in a sliced sphere"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min_phi"),": the min phi that determines the cutoff at the north pole of the sphere"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_phi"),": the max phi that determined the cutoff at the south pole of the sphere")),(0,r.kt)("h2",{id:"sphere-current-implementation"},"Sphere {current implementation}"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sphere id (radius theta_max phi_min phi_max theta_segs phi_segs) endsphere\n")),(0,r.kt)("p",null,"Defines a sphere."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"radius`: the radius of the sphere."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"}," -"),": the max theta of any latitude, resulting in a sliced sphere."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"phi_min"),": min phi that determines cutoff at the SOUTH pole of the sphere (phi=-90)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"phi_max"),": max phi that determined cutoff at the NORTH pole of the sphere (phi=90)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"theta_segs"),": the number of segments in the longitudinal direction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"phi_segs"),": the number of segments in the latitudinal direction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"}," -90 <= phi_min < phi_max <= 90 (degrees).")," "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius, theta_segs, phi_segs > 0")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= theta_max <= 360"))),(0,r.kt)("h2",{id:"newsphere"},"newSphere"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sphere \n    id ( radius  long_max  latt_min  latt_max  segs_long  segs_latt  [brep  brep-type] ) \nendsphere \n")),(0,r.kt)("p",null,"Defines a sphere more like a \u201cglobe\u201d with its \u201crotation axis\u201d along the z-axis."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"`radius:  the radius of the sphere  {put most important geometrical parameters first}."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"long_max[e][f]: {<= 360}"),": the max longitude at any latitude, resulting in a sliced \u201corange.\u201d "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"latt_min[g][h]: {>= -90}"),":   the min latitude, cutting off the South pole."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"latt_max[i][j]: {<=  90}"),":   the max latitude, cutting off theNorth pole."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs_long[k][l]:  {>= 3}"),":    the number of segments in the longitudinal direction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs_latt[m][n]"),":  {>= 2}:    the number of segments in the latitudinal direction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[brep  brep-type]"),":   specify  NOME_TRIAS  or  NOME_QUADS  as in sweeps, etc.")),(0,r.kt)("h2",{id:"ellipsoid-status-up-to-date"},"Ellipsoid (Status: Up-to-date)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ellipsoid id ( radius[o][p]_x radius_y  long_max  latt_min  latt_max  segs_long  segs_latt ) endellipsoid\n")),(0,r.kt)("p",null,"Defines a sphere more like a \u201cglobe\u201d with its \u201crotation axis\u201d along the z-axis."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius[q][r]_x"),":  the radius of the ellipsoid in the x direction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"radius_y"),":  the radius of the ellipsoid in the y direction"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"long_max"),": {<= 360}: the max longitude at any latitude, resulting in a sliced \u201corange.\u201d "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"latt_min"),": {>= -90}:   the min latitude, cutting off the South pole."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"latt_max"),": {<=  90}:   the max latitude, cutting off the North pole."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs_long"),":  {>= 3}:    the number of segments in the longitudinal direction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs_latt"),":  {>= 2}:    the number of segments in the latitudinal direction.")),(0,r.kt)("h2",{id:"torus-status-up-to-date"},"Torus (Status: Up-to-date)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"torus id (rad_maj rad_min theta_max  phi_min  phi_max  segs_theta  segs_phi) endtorus\n")),(0,r.kt)("p",null,"Defines a torus."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rad_maj"),": the major radius"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rad_min"),": the minor radius of the outer ring."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"theta_max"),": specified in degrees. The minor cross-section circle is swept starting at the x-axis and circles the z-axis by the angle theta until thetamax is reached (=< 360)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"phi_min"),": starting angle in degrees around the minor circle. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"phi_max"),": terminating angle in degrees around the minor circle."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= phi_min < phi_max <= 360")," (degrees)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs_theta"),": the number of segments along the major radius."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs_phi"),": the number of segments around the minor radius.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"should we also allow:",(0,r.kt)("inlineCode",{parentName:"p"},"[brep brep-type]"),"-- as in sweeps, etc")),(0,r.kt)("h2",{id:"torus-knot-status-up-to-date"},"Torus Knot (Status: Up-to-date)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"torusknot id (symm turns rad_maj rad_min rad_tube segs_circ segs_sweep) endtorusknot\n")),(0,r.kt)("p",null,"Defines a torus knot."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"symm"),": sweeps through the donut hole = rotational symmetry of knot (+/- OK)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"turns"),": turns around the donut hole (+/- to reverse chirality."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rad_maj"),": the major radius of the donut."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rad_min"),": the minor donut radius (tube radius)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rad_tube"),": radius of swept circle.  For rad_tube := 0, only the sweep path is output."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs_circ"),": the number of segments on the circular cross section."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"segs_sweep"),": the number of segments along the sweep path.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"should we also allow: ",(0,r.kt)("inlineCode",{parentName:"p"},"[brep brep-type]")," -- as in sweeps, etc")),(0,r.kt)("h2",{id:"mobius-strip--status-current-implementation-does-not-use-thickness-uses-radius-twists-cuts-and-segs"},(0,r.kt)("strong",{parentName:"h2"},"Mobius Strip"),"  ",(0,r.kt)("strong",{parentName:"h2"},"(Status: current implementation does not use thickness. uses radius, twists, cuts, and segs)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mobiusstrip id (radius twists cuts segs) endmobiusstrip\n")),(0,r.kt)("p",null,"Defines a mobius strip with a specified number of twists and cuts."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"radius: the width of the band. If there are multiple cuts, then radius = width of all sub-bands + width of all gaps between sub-bands."),(0,r.kt)("li",{parentName:"ul"},"twists: the number of twists in the mobius strip."),(0,r.kt)("li",{parentName:"ul"},"cuts: the number of cuts in the mobius strip band (cuts go parallel to the edges of the band). Gaps and sub-bands will all be of the same width. Sum of widths = radius."),(0,r.kt)("li",{parentName:"ul"},"segs: the number of segments around the band.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"should we also allow: ",(0,r.kt)("inlineCode",{parentName:"p"},"[brep brep-type]")," -- as in sweeps, etc")),(0,r.kt)("h2",{id:"dupin-cycle"},"Dupin Cycle"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dupin id (a b c d u v crosssec) enddupin\n")),(0,r.kt)("p",null,"Defines a Dupin with specified number of cross sections"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"a"),": Radius (x-y plane) of the donut sphere formed by the dupin"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"b"),": Height (x-z plane) of the donut sphere formed by the dupin"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"c"),": x to y radius of the donut sphere"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"d"),": x to z radius of the donut sphere "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"u"),": x to y sphere angle "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"v"),": x to z sphere angle")),(0,r.kt)("h2",{id:"general-cartesian-surface"},"General Cartesian Surface"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"gencartesiansurf id func func_string (x_min x_max y_min y_max x_segs y_segs) endgencartesiansurf\n")),(0,r.kt)("p",null,"Defines a general surface based on a cartesian equation z = f(x,y) evaluated over specified axis bounds and number of segments."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x_min"),": Lower bound of range in x-plane"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x_max"),": Upper bound of range in x-plane"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"y_min"),": Lower bound of range in y-plane"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"y_max"),": Upper bound of range in y-plane"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x_segs"),": Number of segments in x dimension."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"y_segs"),": Number of segments in y dimension."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"func"),": Keyword func is necessary to tell parser to parse func_string."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"func_string"),": Supplied function of form z = f(x,y). See necessary formatting below.")),(0,r.kt)("p",null,"Passed in func_string formatting:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Surrounded by open and close brackets and without spaces"),(0,r.kt)("li",{parentName:"ul"},"Many operations are included, for example:"),(0,r.kt)("li",{parentName:"ul"},"Man   ",(0,r.kt)("em",{parentName:"li"}," Basic operators are supported: +, -, "),", /, %, ^"),(0,r.kt)("li",{parentName:"ul"},"Mathematical functions are supported: avg(), max(), abs(), exp(), log(), sin(), cosh(), etc."),(0,r.kt)("li",{parentName:"ul"},"If and nested-if statements are also supported and take the form z = f(x,y) = if(condition,true_expressionfalse_expression)"),(0,r.kt)("li",{parentName:"ul"},"See ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ArashPartow/exprtk"},"https://github.com/ArashPartow/exprtk")," readme.txt Section 01 and Section 08 for more information on whatoperations/functions/etc. are supported"),(0,r.kt)("li",{parentName:"ul"},"See ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genCartesianSurfExample.nom"},"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genCartesianSurfExample.nom")," for example usage")),(0,r.kt)("h2",{id:"general-parametric-surface"},"General Parametric Surface"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"genparametricsurf id funcX funcX_string_x funcY funcY_string funcZ funcZ_string (u_min u_max v_min v_max u_segs v_segs) endgenparametricsurf\n")),(0,r.kt)("p",null,"Defines a general surface based on parametric equations x(u,v), y(u,v), and z(u,v) evaluated over specified axis bounds and number of segments in u and v."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"u_min: Lower bound of range in u-plane"),(0,r.kt)("li",{parentName:"ul"},"u_max: Upper bound of range in u-plane"),(0,r.kt)("li",{parentName:"ul"},"v_min: Lower bound of range in v-plane"),(0,r.kt)("li",{parentName:"ul"},"v_max: Upper bound of range in v-plane"),(0,r.kt)("li",{parentName:"ul"},"u_segs: Number of segments in u dimension"),(0,r.kt)("li",{parentName:"ul"},"v_segs: Number of segments in v dimension"),(0,r.kt)("li",{parentName:"ul"},"funcX: Keyword funcX is necessary to tell parser to parse funcX_string."),(0,r.kt)("li",{parentName:"ul"},"funcY: Keyword funcY is necessary to tell parser to parse funcY_string."),(0,r.kt)("li",{parentName:"ul"},"funcZ: Keyword funcZ is necessary to tell parser to parse funcZ_string."),(0,r.kt)("li",{parentName:"ul"},"funcX_string: Function x(u,v). See necessary formatting below."),(0,r.kt)("li",{parentName:"ul"},"funcY_string: Function y(u,v). See necessary formatting below."),(0,r.kt)("li",{parentName:"ul"},"funcZ_string: Function z(u,v). See necessary formatting below.\nPassed in funcX_string, funcY_string, and funcZ_string formatting:"),(0,r.kt)("li",{parentName:"ul"},"Surrounded by opened and closed brackets and without spaces"),(0,r.kt)("li",{parentName:"ul"},"funcX_string, funcY_string, and funcZ_string take the form x(u,v), y(u,v), and z(u,v) respectively, where x, y, and z are each defined by a parametric function dependant on variables u and v."),(0,r.kt)("li",{parentName:"ul"},"Many operations are included, for example:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Basic operators are supported: +, -, *, /, %, ^"),(0,r.kt)("li",{parentName:"ul"},"Mathematical functions are supported: avg(), max(), abs(), exp(), log(), sin(), cosh(), etc."),(0,r.kt)("li",{parentName:"ul"},"If and nested-if statements are also supported and take the form z = f(x,y) = if(condition,true_expression,false_expression)"),(0,r.kt)("li",{parentName:"ul"},"See ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ArashPartow/exprtk"},"https://github.com/ArashPartow/exprtk")," readme.txt Section 01 and Section 08 for more information on what operationsfunctions/   etc. are supported"))),(0,r.kt)("li",{parentName:"ul"},"See ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genParametricSurfExample.nom"},"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genParametricSurfExample.nom"),"  for example usage")),(0,r.kt)("h2",{id:"general-implicit-surface"},"General Implicit Surface"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"genimplicitsurf id func func_string (x_min x_max y_min y_max z_min z_max x_segs y_segs z_segs) endgenimplicitsurf\n")),(0,r.kt)("p",null,"Defines a general surface based on an implicit equation f(x,y,z) = b, where b is a given isolevel. It is evaluated over the specified axis bounds and number of segments."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"x_min: Lower bound of range in x-plane"),(0,r.kt)("li",{parentName:"ul"},"x_max: Upper bound of range in x-plane"),(0,r.kt)("li",{parentName:"ul"},"y_min: Lower bound of range in y-plane"),(0,r.kt)("li",{parentName:"ul"},"y_max: Upper bound of range in y-plane"),(0,r.kt)("li",{parentName:"ul"},"z_min: Lower bound of range in z-plane"),(0,r.kt)("li",{parentName:"ul"},"z_max: Upper bound of range in z-plane"),(0,r.kt)("li",{parentName:"ul"},"x_segs: Number of segments in x dimension"),(0,r.kt)("li",{parentName:"ul"},"y_segs: Number of segments in y dimension"),(0,r.kt)("li",{parentName:"ul"},"z_segs: Number of segments in z dimension"),(0,r.kt)("li",{parentName:"ul"},"func: Keyword func is necessary to tell parser to parse func_string."),(0,r.kt)("li",{parentName:"ul"},"func_string: Supplied function of form f(x,y,z) - b, where b is the isolevel (func_string is assuming user has modified input expression so that f(x,y,z) = b is rewritten as f(x,y,z) - b = 0, with \u201c= 0\u201d omitted from func_string). See necessary formatting below.\nPassed in func_string formatting:"),(0,r.kt)("li",{parentName:"ul"},"Surrounded by opened and closed brackets and without spaces"),(0,r.kt)("li",{parentName:"ul"},"Many operations are included, for example:"),(0,r.kt)("li",{parentName:"ul"},"Basic operators are supported: +, -, *, /, %, ^"),(0,r.kt)("li",{parentName:"ul"},"Mathematical functions are supported: avg(), max(), abs(), exp(), log(), sin(), cosh(), etc."),(0,r.kt)("li",{parentName:"ul"},"If and nested-if statements are also supported and take the form z = f(x,y) = if(condition,true_expressionfalse_expression)"),(0,r.kt)("li",{parentName:"ul"},"See ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ArashPartow/exprtk"},"https://github.com/ArashPartow/exprtk")," readme.txt Section 01 and Section 08 for more information on what operationsfunctions/etc. are supported"),(0,r.kt)("li",{parentName:"ul"},"See ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genImplicitSurfExample.nom"},"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genImplicitSurfExample.nom")," for example usage")))}d.isMDXComponent=!0}}]);