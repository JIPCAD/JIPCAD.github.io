"use strict";(self.webpackChunkjipcad=self.webpackChunkjipcad||[]).push([[526],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return c}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=p(n),c=a,k=d["".concat(s,".").concat(c)]||d[c]||u[c]||l;return n?i.createElement(k,r(r({ref:t},m),{},{components:n})):i.createElement(k,r({ref:t},m))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var p=2;p<l;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6018:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return m},default:function(){return d}});var i=n(7462),a=n(3366),l=(n(7294),n(3905)),r=["components"],o={sidebar_position:3},s="Generators",p={unversionedId:"lang-ref/generators",id:"lang-ref/generators",isDocsHomePage:!1,title:"Generators",description:"Point",source:"@site/docs/lang-ref/generators.md",sourceDirName:"lang-ref",slug:"/lang-ref/generators",permalink:"/docs/lang-ref/generators",editUrl:"https://github.com/JIPCAD/NOME3/docs/lang-ref/generators.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Numerical Parameters and Sliders",permalink:"/docs/lang-ref/numerical-sliders"},next:{title:"Rendering Specifications",permalink:"/docs/lang-ref/rendering"}},m=[{value:"Point",id:"point",children:[],level:2},{value:"Controlpoint",id:"controlpoint",children:[],level:2},{value:"Polyline",id:"polyline",children:[],level:2},{value:"Bezier Curve",id:"bezier-curve",children:[],level:2},{value:"B-Spline",id:"b-spline",children:[],level:2},{value:"Face",id:"face",children:[],level:2},{value:"Mesh",id:"mesh",children:[],level:2},{value:"Sweep",id:"sweep",children:[],level:2},{value:"Sweep Morph",id:"sweep-morph",children:[],level:2},{value:"Sweep Morph Visualizer",id:"sweep-morph-visualizer",children:[],level:2},{value:"Circle",id:"circle",children:[],level:2},{value:"Disk",id:"disk",children:[],level:2},{value:"Cylinder",id:"cylinder",children:[],level:2},{value:"Cone <em>(this command is not implemented)</em>",id:"cone-this-command-is-not-implemented",children:[],level:2},{value:"Funnel",id:"funnel",children:[],level:2},{value:"Tunnel",id:"tunnel",children:[],level:2},{value:"Sphere",id:"sphere",children:[],level:2},{value:"newSphere <em>(this command is not implemented)</em>",id:"newsphere-this-command-is-not-implemented",children:[],level:2},{value:"Ellipsoid",id:"ellipsoid",children:[],level:2},{value:"Torus",id:"torus",children:[],level:2},{value:"Torus Knot",id:"torus-knot",children:[],level:2},{value:"Mobius Strip  <em>(Status: current implementation does not use thickness. uses radius, twists, cuts, and segs)</em>",id:"mobius-strip--status-current-implementation-does-not-use-thickness-uses-radius-twists-cuts-and-segs",children:[],level:2},{value:"Dupin Cycle",id:"dupin-cycle",children:[],level:2},{value:"General Cartesian Surface",id:"general-cartesian-surface",children:[],level:2},{value:"General Parametric Surface",id:"general-parametric-surface",children:[],level:2},{value:"General Implicit Surface",id:"general-implicit-surface",children:[],level:2}],u={toc:m};function d(e){var t=e.components,n=(0,a.Z)(e,r);return(0,l.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"generators"},"Generators"),(0,l.kt)("h2",{id:"point"},"Point"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"point id (x y z) endpoint\n")),(0,l.kt)("p",null,"Defines a point at the specified x, y, and z coordinates."),(0,l.kt)("h2",{id:"controlpoint"},"Controlpoint"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"controlpoint id  point p_id  [scale (sx sy sz)] [rotate (rx ry rz)] [crosssection crosssection_id] [reverse] endcontrolpoint\n")),(0,l.kt)("p",null,"Enhances a point (",(0,l.kt)("inlineCode",{parentName:"p"},"p_id"),") with additional parameters controlling the non-uniform scaling (",(0,l.kt)("inlineCode",{parentName:"p"},"sx"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"sy"),") and rotation (",(0,l.kt)("inlineCode",{parentName:"p"},"rz"),") and tilting (",(0,l.kt)("inlineCode",{parentName:"p"},"rx"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ry"),") of the cross section swept along a path. (See ",(0,l.kt)("strong",{parentName:"p"},"Sweep"),")"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(sx sy sz)"),": scales the cross-section located at the controlpoint by a factor of ",(0,l.kt)("inlineCode",{parentName:"li"},"sx")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"sy"),". (Note: ",(0,l.kt)("inlineCode",{parentName:"li"},"sz")," is irrelevant)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(rx ry rz)"),": ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rz"),": angle about which the cross section located at the controlpoint is rotated"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rx"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"ry"),": angles about which the cross section located at the controlpoint is tilted"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"crosssection_id"),": the cross section to be defined at this controlpoint "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'"reverse"'),": reverses the sweep at the controlpoint")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note:")," Interpolation rules for scaling and rotation of cross sections are determined by the path type's interpolation rules. See ",(0,l.kt)("strong",{parentName:"p"},"Sweep")," ",(0,l.kt)("inlineCode",{parentName:"p"},"warp"),".",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("strong",{parentName:"p"},"Note:")," the ",(0,l.kt)("inlineCode",{parentName:"p"},"crosssection")," parameter should be used in a path for the ",(0,l.kt)("strong",{parentName:"p"},"Sweep Morph")," generator."),(0,l.kt)("h2",{id:"polyline"},"Polyline"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"polyline id ( point_idlist ) [closed] [surface surface_id] endpolyline\n")),(0,l.kt)("p",null,"Defines a polyline, a chain of piecewise linear segments. You can optionally make it closed, i.e., the last point connects back to the first."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,l.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,l.kt)("inlineCode",{parentName:"li"},"point2")," ...")),(0,l.kt)("h2",{id:"bezier-curve"},"Bezier Curve"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"beziercurve id ( point_idlist ) segs {segs} endbeziercurve\n")),(0,l.kt)("p",null,"Defines a Bezier curve."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,l.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,l.kt)("inlineCode",{parentName:"li"},"point2")," ..."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"{segs}"),": the number of segments into which the Bezier curve is sampled.")),(0,l.kt)("h2",{id:"b-spline"},"B-Spline"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"bspline id order {order} (point_idlist) segs {segs} endbspline\n")),(0,l.kt)("p",null,"Defines a B-spline."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"{order}"),": integer that sets the B-spline's DEGREE to be ",(0,l.kt)("inlineCode",{parentName:"li"},"{order}-1"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,l.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,l.kt)("inlineCode",{parentName:"li"},"point2")," ..."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"{segs}"),": the number of segments into which the B-spline is sampled."),(0,l.kt)("li",{parentName:"ul"},"The number of control points must be greater than or equal to ",(0,l.kt)("inlineCode",{parentName:"li"},"{order}")),(0,l.kt)("li",{parentName:"ul"},"For closed curves, there must be at least ",(0,l.kt)("inlineCode",{parentName:"li"},"{order}-1")," control points.")),(0,l.kt)("h2",{id:"face"},"Face"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"face id (point_idlist) [surface surface_id] endface\n")),(0,l.kt)("p",null,"Defines a face from a list of points. Front face uses counter-clockwise winding."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,l.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,l.kt)("inlineCode",{parentName:"li"},"point2")," ...")),(0,l.kt)("h2",{id:"mesh"},"Mesh"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"mesh id \n    point pointId1 id1 (x y z) endpoint \n    \u2026\n    point pointIdN (x y z) endpoint\n    \n    face faceId1 ( point_idlist1 ) [surface surface_id] endface \n    ... \n    face faceIdN ( point_idlistN) [surface surface_id] endface\nendmesh\n")),(0,l.kt)("p",null,"Also creates a collection of faces, which can optionally be colored. Faces in a mesh can then be referred to in the rest of the program via a hierarchical name: id.faceId. Variable names must be unique within a mesh."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"faceId"),": the name of the face"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"point_idlist"),": a list of points of the form ",(0,l.kt)("inlineCode",{parentName:"li"},"point1")," ",(0,l.kt)("inlineCode",{parentName:"li"},"point2")," ..."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pointId"),": the name of the point")),(0,l.kt)("h2",{id:"sweep"},"Sweep"),(0,l.kt)("p",null,"A sweep describes the result of sweeping a ",(0,l.kt)("inlineCode",{parentName:"p"},"crosssection")," along a ",(0,l.kt)("inlineCode",{parentName:"p"},"path"),". "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"sweep id  \n  crosssection  id [reverse] [begincap] [endcap]  endcrosssection\n  path  id [mintorsion] [azimuth a_angle] [twist t_angle] [cutbegin] [cutend]  endpath\n  [brep brep-type]\nendsweep\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"crosssection")," - can be a polyline, circle, beziercurve, or bspline."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\u201creverse\u201d"),":  if present, flips the orientation of the crosssection, turning the generated brep-surface inside out."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\u201cbegincap\u201d"),":  if present, draw the starting face (with outward normal)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\u201cendcap\u201d"),":  if present, draw the ending face (with outward normal")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"path")," - can be a polyline, circle, beziercurve, or bspline."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Each path has a set of Frenet frames (tangents, normals, & binormals) that are used to determine how the crosssection will twist along the path. The user can control the twist in four ways and these options are additive in the order given below:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mintorsion"),": minimizes the twisting of the intrinsic Frenet frame."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"azimuth"),": angle=",(0,l.kt)("inlineCode",{parentName:"li"},"a_angle")," about the tangent that all Frenet frames will be rotated by."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"twist"),": angle=",(0,l.kt)("inlineCode",{parentName:"li"},"t_angle")," about the tangent that specifies the overall amount of twist from the first Frenet frame to the last."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"warp"),": sets each twist angle explicitly at specified controlpoints in the path. (See ",(0,l.kt)("strong",{parentName:"li"},"Controlpoint"),")",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"These controlpoints also permit rotating and non-uniformly scaling of the crosssection at these locations.  Regular points act like control points with no additional transformations.  At any sample points between adjacent controlpoint, the transformation variables are interpolated in the same way that the x, y, and z-coordinates are being interpolated. (e.g. by a cubic polynomial for the cubic Bspline)"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cutbegin"),": if present, does not draw the first segment of the sweep"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"cutend"),": if present, does not draw the last segment of the sweep")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"brep_type"),": can be either TRIANGLES (=default) or QUADRILATERALS."),(0,l.kt)("h2",{id:"sweep-morph"},"Sweep Morph"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"sweepmorph id \n    [begincap] [endcap]\n    path  id [mintorsion] [azimuth a_angle] [twist t_angle] [cutbegin] [cutend]  endpath\nendsweepmorph\n")),(0,l.kt)("p",null,"Linearly interpolates between cross sections that are specified at ",(0,l.kt)("a",{parentName:"p",href:"#controlpoint"},"control points"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"See ",(0,l.kt)("a",{parentName:"li",href:"#sweep"},(0,l.kt)("strong",{parentName:"a"},"Sweep"))," for information on the flags."),(0,l.kt)("li",{parentName:"ul"},"If a ",(0,l.kt)("inlineCode",{parentName:"li"},"crosssection")," is defined at only one control point, the result will be a generic Sweep with that ",(0,l.kt)("inlineCode",{parentName:"li"},"crosssection"),"."),(0,l.kt)("li",{parentName:"ul"},"Linear interpolations of cross sections are performed between subsequent control points where cross sections are specified."),(0,l.kt)("li",{parentName:"ul"},"Points without ",(0,l.kt)("inlineCode",{parentName:"li"},"crosssection")," specifications and are...",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"before the first control point with a specified ",(0,l.kt)("inlineCode",{parentName:"li"},"crosssection")," will adopt this first ",(0,l.kt)("inlineCode",{parentName:"li"},"crosssection"),"."),(0,l.kt)("li",{parentName:"ul"},"after the last control point with a specified ",(0,l.kt)("inlineCode",{parentName:"li"},"crosssection")," will adopt this last ",(0,l.kt)("inlineCode",{parentName:"li"},"crosssection"),".")))),(0,l.kt)("h2",{id:"sweep-morph-visualizer"},"Sweep Morph Visualizer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"morphvisualizer id \n    sweep sweep_id\n    index (seg_index)\nendmorphvisualizer\n")),(0,l.kt)("p",null,"Displays the cross section of a Sweep at index ",(0,l.kt)("inlineCode",{parentName:"p"},"seg_index"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sweep_id"),": the sweep."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"seg_index"),": the index of the cross section to display.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note"),": ",(0,l.kt)("inlineCode",{parentName:"p"},"sweep_id")," need not be a Sweep Morph. The visualizer works for any sweep and will display cross sections with scales and cross section morphs applied. Rotations, twists, and azimuth changes in a sweep are ",(0,l.kt)("em",{parentName:"p"},"not")," reflected in the morph visualizer."),(0,l.kt)("h2",{id:"circle"},"Circle"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"circle id (radius segs) endcircle\n")),(0,l.kt)("p",null,"Defines a circle."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),": the radius."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs"),": the number of line segments."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"segs")," :cannot be negative.")),(0,l.kt)("h2",{id:"disk"},"Disk"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Disk id (radius theta_max theta_segs) enddisk\n")),(0,l.kt)("p",null,"Defines a (partial) disk."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),": the radius of the disk."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_max"),": the max theta angle (<= 360 degrees), resulting in a wedge."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_segs"),": the number of segments in the wedge perimeter."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),",",(0,l.kt)("inlineCode",{parentName:"li"}," theta_segs")," cannot be negative."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Theta_max")," must be between 0 ~ 360 degrees.")),(0,l.kt)("h2",{id:"cylinder"},"Cylinder"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"cylinder id (radius height theta_max theta_segs [botcap] [topcap] ) endcylinder\n")),(0,l.kt)("p",null,"Defines a (wedge of a) cylinder."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),": the radius at the bottom."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"height"),": the height of a complete cone."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_max"),": the max theta angle (<= 360 degrees), resulting in a cylinder wedge."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_segs"),": the number of segments in the theta direction."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\u201cbotcap\u201d"),": if present, draw the bottom face (with downward normal)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\u201ctopcap\u201d"),": if present, draw the top face on the cylinder."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Radius"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"height"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"theta_segs")," cannot be negative."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Theta_max")," must be between 0 ~ 360 degrees.")),(0,l.kt)("h2",{id:"cone-this-command-is-not-implemented"},"Cone ",(0,l.kt)("em",{parentName:"h2"},"(this command is not implemented)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"cone id (radius height hgt_max theta_max theta_segs [botcap] [topcap] ) endcone\n")),(0,l.kt)("p",null,"Defines a (possibly truncated) cone."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),": the radius at the bottom."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"height"),": the height of a complete cone."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"hgt_max"),": the fraction of the height ","[0, 1]"," at which the cone is truncated."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_max"),": the max theta angle (<= 360 degrees), resulting in a partial cone."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_segs"),": the number of segments in the theta direction."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\u201cbotcap\u201d"),": if present, draw the bottom face (with downward normal)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\u201ctopcap\u201d"),": if present, draw the top face on a truncated cone.2")),(0,l.kt)("h2",{id:"funnel"},"Funnel"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"funnel id (radius ratio height segs) endfunnel\n")),(0,l.kt)("p",null,"Defines a funnel, i.e. the mantle of a truncated cone."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),": the radius of the \u201cbottom\u201d ring."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ratio"),": the ratio of the radii of the top ring and the bottom ring."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"height"),": the height of the truncated cone."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs"),": the number of segments around the equator."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"ratio"),",",(0,l.kt)("inlineCode",{parentName:"li"}," height"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"segs")," cannot be negative.")),(0,l.kt)("h2",{id:"tunnel"},"Tunnel"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"tunnel id (radius ratio height segs) endtunnel\n")),(0,l.kt)("p",null,"Defines a tunnel made from two Funnels, glued bottom-to-bottom."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),": the radius of the \u201cmiddle\u201d ring."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ratio"),": the ratio of the radii of the two outer rings and the middle ring."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"height"),": the heights of each of the truncated cones."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs"),": the number of segments around the equator."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),",",(0,l.kt)("inlineCode",{parentName:"li"}," ratio"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"height"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"segs")," cannot be negative.")),(0,l.kt)("h2",{id:"sphere"},"Sphere"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"sphere id (radius theta_max phi_min phi_max theta_segs phi_segs) endsphere\n")),(0,l.kt)("p",null,"Defines a sphere."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),": the radius of the sphere."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_max"),": the max theta of any latitude, resulting in a sliced sphere."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"phi_min"),": min phi that determines cutoff at the SOUTH pole of the sphere (phi=-90)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"phi_max"),": max phi that determined cutoff at the NORTH pole of the sphere (phi=90)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_segs"),": the number of segments in the longitudinal direction."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"phi_segs"),": the number of segments in the latitudinal direction."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"}," -90 <= phi_min < phi_max <= 90 (degrees).")," "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius, theta_segs, phi_segs > 0")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"0 <= theta_max <= 360"))),(0,l.kt)("h2",{id:"newsphere-this-command-is-not-implemented"},"newSphere ",(0,l.kt)("em",{parentName:"h2"},"(this command is not implemented)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"sphere \n    id ( radius  long_max  latt_min  latt_max  segs_long  segs_latt  [brep  brep-type] ) \nendsphere \n")),(0,l.kt)("p",null,"Defines a sphere more like a \u201cglobe\u201d with its \u201crotation axis\u201d along the z-axis."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius"),":  the radius of the sphere  {put most important geometrical parameters first}."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"long_max[e][f]: {<= 360}"),": the max longitude at any latitude, resulting in a sliced \u201corange.\u201d "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"latt_min[g][h]: {>= -90}"),":   the min latitude, cutting off the South pole."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"latt_max[i][j]: {<=  90}"),":   the max latitude, cutting off theNorth pole."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs_long[k][l]:  {>= 3}"),":    the number of segments in the longitudinal direction."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs_latt[m][n]:  {>= 2}"),":    the number of segments in the latitudinal direction."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[brep  brep-type]"),":   specify  NOME_TRIAS  or  NOME_QUADS  as in sweeps, etc.")),(0,l.kt)("h2",{id:"ellipsoid"},"Ellipsoid"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"ellipsoid id ( radius[o][p]_x radius_y  long_max  latt_min  latt_max  segs_long  segs_latt ) endellipsoid\n")),(0,l.kt)("p",null,"Defines a sphere more like a \u201cglobe\u201d with its \u201crotation axis\u201d along the z-axis."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius[q][r]_x"),":  the radius of the ellipsoid in the x direction"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"radius_y"),":  the radius of the ellipsoid in the y direction"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"long_max"),": {<= 360}: the max longitude at any latitude, resulting in a sliced \u201corange.\u201d "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"latt_min"),": {>= -90}:   the min latitude, cutting off the South pole."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"latt_max"),": {<=  90}:   the max latitude, cutting off the North pole."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs_long"),":  {>= 3}:    the number of segments in the longitudinal direction."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs_latt"),":  {>= 2}:    the number of segments in the latitudinal direction.")),(0,l.kt)("h2",{id:"torus"},"Torus"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"torus id (rad_maj rad_min theta_max  phi_min  phi_max  segs_theta  segs_phi) endtorus\n")),(0,l.kt)("p",null,"Defines a torus."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rad_maj"),": the major radius"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rad_min"),": the minor radius of the outer ring."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"theta_max"),": specified in degrees. The minor cross-section circle is swept starting at the x-axis and circles the z-axis by the angle theta until thetamax is reached (=< 360)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"phi_min"),": starting angle in degrees around the minor circle. "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"phi_max"),": terminating angle in degrees around the minor circle."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"0 <= phi_min < phi_max <= 360")," (degrees)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs_theta"),": the number of segments along the major radius."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs_phi"),": the number of segments around the minor radius.")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"should we also allow:",(0,l.kt)("inlineCode",{parentName:"p"},"[brep brep-type]"),"-- as in sweeps, etc")),(0,l.kt)("h2",{id:"torus-knot"},"Torus Knot"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"torusknot id (symm turns rad_maj rad_min rad_tube segs_circ segs_sweep) endtorusknot\n")),(0,l.kt)("p",null,"Defines a torus knot."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"symm"),": sweeps through the donut hole = rotational symmetry of knot (+/- OK)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"turns"),": turns around the donut hole (+/- to reverse chirality."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rad_maj"),": the major radius of the donut."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rad_min"),": the minor donut radius (tube radius)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"rad_tube"),": radius of swept circle.  For rad_tube := 0, only the sweep path is output."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs_circ"),": the number of segments on the circular cross section."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"segs_sweep"),": the number of segments along the sweep path.")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"should we also allow: ",(0,l.kt)("inlineCode",{parentName:"p"},"[brep brep-type]")," -- as in sweeps, etc")),(0,l.kt)("h2",{id:"mobius-strip--status-current-implementation-does-not-use-thickness-uses-radius-twists-cuts-and-segs"},"Mobius Strip  ",(0,l.kt)("em",{parentName:"h2"},"(Status: current implementation does not use thickness. uses radius, twists, cuts, and segs)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"mobiusstrip id (radius twists cuts segs) endmobiusstrip\n")),(0,l.kt)("p",null,"Defines a mobius strip with a specified number of twists and cuts."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"radius: the width of the band. If there are multiple cuts, then radius = width of all sub-bands + width of all gaps between sub-bands."),(0,l.kt)("li",{parentName:"ul"},"twists: the number of twists in the mobius strip."),(0,l.kt)("li",{parentName:"ul"},"cuts: the number of cuts in the mobius strip band (cuts go parallel to the edges of the band). Gaps and sub-bands will all be of the same width. Sum of widths = radius."),(0,l.kt)("li",{parentName:"ul"},"segs: the number of segments around the band.")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"should we also allow: ",(0,l.kt)("inlineCode",{parentName:"p"},"[brep brep-type]")," -- as in sweeps, etc")),(0,l.kt)("h2",{id:"dupin-cycle"},"Dupin Cycle"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"dupin id (a b c d u v crosssec) enddupin\n")),(0,l.kt)("p",null,"Defines a Dupin with specified number of cross sections"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"a"),": Radius (x-y plane) of the donut sphere formed by the dupin"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"b"),": Height (x-z plane) of the donut sphere formed by the dupin"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"c"),": x to y radius of the donut sphere"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"d"),": x to z radius of the donut sphere "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"u"),": x to y sphere angle "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"v"),": x to z sphere angle")),(0,l.kt)("h2",{id:"general-cartesian-surface"},"General Cartesian Surface"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"gencartesiansurf id func func_string (x_min x_max y_min y_max x_segs y_segs) endgencartesiansurf\n")),(0,l.kt)("p",null,"Defines a general surface based on a cartesian equation z = f(x,y) evaluated over specified axis bounds and number of segments."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x_min"),": Lower bound of range in x-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x_max"),": Upper bound of range in x-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"y_min"),": Lower bound of range in y-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"y_max"),": Upper bound of range in y-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x_segs"),": Number of segments in x dimension."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"y_segs"),": Number of segments in y dimension."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"func"),": Keyword ",(0,l.kt)("inlineCode",{parentName:"li"},"func")," is necessary to tell parser to parse ",(0,l.kt)("inlineCode",{parentName:"li"},"func_string"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"func_string"),": Supplied function of form z = f(x,y). See necessary formatting below.")),(0,l.kt)("p",null,"Passed in ",(0,l.kt)("inlineCode",{parentName:"p"},"func_string")," formatting:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Surrounded by open and close brackets and without spaces"),(0,l.kt)("li",{parentName:"ul"},"Many operations are included, for example:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Basic operators are supported: +, -, ","*",", /, %, ^"),(0,l.kt)("li",{parentName:"ul"},"Mathematical functions are supported: avg(), max(), abs(), exp(), log(), sin(), cosh(), etc."),(0,l.kt)("li",{parentName:"ul"},"If and nested-if statements are also supported and take the form z = f(x,y) = if(condition,true_expression,false_expression)"),(0,l.kt)("li",{parentName:"ul"},"See ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/ArashPartow/exprtk"},"https://github.com/ArashPartow/exprtk")," readme.txt Section 01 and Section 08 for more information on what operations/functions/etc. are supported"))),(0,l.kt)("li",{parentName:"ul"},"See ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genCartesianSurfExample.nom"},"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genCartesianSurfExample.nom")," for example usage")),(0,l.kt)("h2",{id:"general-parametric-surface"},"General Parametric Surface"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"genparametricsurf id funcX funcX_string_x funcY funcY_string funcZ funcZ_string (u_min u_max v_min v_max u_segs v_segs) endgenparametricsurf\n")),(0,l.kt)("p",null,"Defines a general surface based on parametric equations x(u,v), y(u,v), and z(u,v) evaluated over specified axis bounds and number of segments in u and v."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"u_min"),": Lower bound of range in u-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"u_max"),": Upper bound of range in u-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"v_min"),": Lower bound of range in v-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"v_max"),": Upper bound of range in v-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"u_segs"),": Number of segments in u dimension"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"v_segs"),": Number of segments in v dimension"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"funcX"),": Keyword ",(0,l.kt)("inlineCode",{parentName:"li"},"funcX")," is necessary to tell parser to parse ",(0,l.kt)("inlineCode",{parentName:"li"},"funcX_string"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"funcY"),": Keyword ",(0,l.kt)("inlineCode",{parentName:"li"},"funcY")," is necessary to tell parser to parse ",(0,l.kt)("inlineCode",{parentName:"li"},"funcY_string"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"funcZ"),": Keyword ",(0,l.kt)("inlineCode",{parentName:"li"},"funcZ")," is necessary to tell parser to parse ",(0,l.kt)("inlineCode",{parentName:"li"},"funcZ_string"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"funcX_string"),": Function x(u,v). See necessary formatting below."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"funcY_string"),": Function y(u,v). See necessary formatting below."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"funcZ_string"),": Function z(u,v). See necessary formatting below.")),(0,l.kt)("p",null,"Passed in ",(0,l.kt)("inlineCode",{parentName:"p"},"funcX_string"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"funcY_string"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"funcZ_string")," formatting:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Surrounded by opened and closed brackets and without spaces"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"funcX_string"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"funcY_string"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"funcZ_string")," take the form x(u,v), y(u,v), and z(u,v) respectively, where x, y, and z are each defined by a parametric function dependant on variables u and v."),(0,l.kt)("li",{parentName:"ul"},"Many operations are included, for example:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Basic operators are supported: +, -, ","*",", /, %, ^"),(0,l.kt)("li",{parentName:"ul"},"Mathematical functions are supported: avg(), max(), abs(), exp(), log(), sin(), cosh(), etc."),(0,l.kt)("li",{parentName:"ul"},"If and nested-if statements are also supported and take the form z = f(x,y) = if(condition,true_expression,false_expression)"),(0,l.kt)("li",{parentName:"ul"},"See ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/ArashPartow/exprtk"},"https://github.com/ArashPartow/exprtk")," readme.txt Section 01 and Section 08 for more information on what operations/functions/etc. are supported"))),(0,l.kt)("li",{parentName:"ul"},"See ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genParametricSurfExample.nom"},"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genParametricSurfExample.nom"),"  for example usage")),(0,l.kt)("h2",{id:"general-implicit-surface"},"General Implicit Surface"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"genimplicitsurf id func func_string (x_min x_max y_min y_max z_min z_max x_segs y_segs z_segs) endgenimplicitsurf\n")),(0,l.kt)("p",null,"Defines a general surface based on an implicit equation f(x,y,z) = b, where b is a given isolevel. It is evaluated over the specified axis bounds and number of segments."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x_min"),": Lower bound of range in x-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x_max"),": Upper bound of range in x-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"y_min"),": Lower bound of range in y-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"y_max"),": Upper bound of range in y-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"z_min"),": Lower bound of range in z-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"z_max"),": Upper bound of range in z-plane"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x_segs"),": Number of segments in x dimension"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"y_segs"),": Number of segments in y dimension"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"z_segs"),": Number of segments in z dimension"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"func"),": Keyword ",(0,l.kt)("inlineCode",{parentName:"li"},"func")," is necessary to tell parser to parse ",(0,l.kt)("inlineCode",{parentName:"li"},"func_string"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"func_string"),": Supplied function of form f(x,y,z) - b, where b is the isolevel (",(0,l.kt)("inlineCode",{parentName:"li"},"func_string")," is assuming user has modified input expression so that f(x,y,z) = b is rewritten as f(x,y,z) - b = 0, with \u201c= 0\u201d omitted from ",(0,l.kt)("inlineCode",{parentName:"li"},"func_string"),"). See necessary formatting below.")),(0,l.kt)("p",null,"Passed in ",(0,l.kt)("inlineCode",{parentName:"p"},"func_string")," formatting:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Surrounded by opened and closed brackets and without spaces"),(0,l.kt)("li",{parentName:"ul"},"Many operations are included, for example:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Basic operators are supported: +, -, ","*",", /, %, ^"),(0,l.kt)("li",{parentName:"ul"},"Mathematical functions are supported: avg(), max(), abs(), exp(), log(), sin(), cosh(), etc."),(0,l.kt)("li",{parentName:"ul"},"If and nested-if statements are also supported and take the form z = f(x,y) = if(condition,true_expression,false_expression)"),(0,l.kt)("li",{parentName:"ul"},"See ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/ArashPartow/exprtk"},"https://github.com/ArashPartow/exprtk")," readme.txt Section 01 and Section 08 for more information on what operations/functions/etc. are supported"))),(0,l.kt)("li",{parentName:"ul"},"See ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genImplicitSurfExample.nom"},"https://github.com/randyfan/NOME3/blob/master/ExampleNOMEFiles/genImplicitSurfExample.nom")," for example usage")))}d.isMDXComponent=!0}}]);