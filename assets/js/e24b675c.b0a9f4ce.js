"use strict";(self.webpackChunkjipcad=self.webpackChunkjipcad||[]).push([[182],{3905:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return h}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),d=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=d(e.components);return n.createElement(c.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(r),h=a,m=u["".concat(c,".").concat(h)]||u[h]||l[h]||o;return r?n.createElement(m,i(i({ref:t},p),{},{components:r})):n.createElement(m,i({ref:t},p))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=r[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},574:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return p},default:function(){return u}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),i=["components"],s={sidebar_position:5},c="Error Reporting Module",d={unversionedId:"error-report",id:"error-report",isDocsHomePage:!1,title:"Error Reporting Module",description:"(Go to NOME3/Application/Parsing/SourceManager.CPP). There, you will find the ReportErrors and CheckStatement Methods, the two key methods in building an instance checker.",source:"@site/docs/error-report.md",sourceDirName:".",slug:"/error-report",permalink:"/docs/error-report",editUrl:"https://github.com/JIPCAD/NOME3/docs/error-report.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Geometric Manipulation",permalink:"/docs/lang-ref/manipulation"}},p=[{value:"Important Variables:",id:"important-variables",children:[],level:2},{value:"Building Instance Syntax Checkers:",id:"building-instance-syntax-checkers",children:[],level:2}],l={toc:p};function u(e){var t=e.components,r=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"error-reporting-module"},"Error Reporting Module"),(0,o.kt)("p",null,"(Go to NOME3/Application/Parsing/SourceManager.CPP). There, you will find the ",(0,o.kt)("inlineCode",{parentName:"p"},"ReportErrors")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"CheckStatement")," Methods, the two key methods in building an instance checker. "),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ReportErrors")," Method parses the nom.g4 file, and tokenizes the code so it can be parsed by the CheckStatement Methods"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"CheckStatement")," Method goes through, line-by-line, the code looking for key phrases. If it finds an illegal phrase before it finds a legal phrase, it immediately errors. "),(0,o.kt)("h2",{id:"important-variables"},"Important Variables:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"std::vector<std::vector<std::string>> parsedcode -> 2d Vector which contains each word for the code by line numbers. \nstd::unordered_map<std::string, std::string> shapemap -> Hashmap that maps each phrase to its endphrase (circle -> endcircle) \nstd::unordered_map<std::string, std::string> idmap; -> Map of IDs\nstd::unordered_map<std::string, std::string> referencemap; -> Map of References (store anything you have to remember other than ids) \n")),(0,o.kt)("h2",{id:"building-instance-syntax-checkers"},"Building Instance Syntax Checkers:"),(0,o.kt)("p",null," Starting at line 212, There is a place where you can call your instance syntax checkers. Each checker takes in the parsed code, idmap, referencemap, the ith and jth location of where you are currently checking, and the shapemap.\nYour function should either return {error} or a vector of the ith and jth location of where your syntax checker found the endphrases. There are already a lot of syntax checkers implemented, you can use things like CheckInstance() to check an instance if your syntax checker comes up to an instance for example.\nThese functions are implemented for you "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"balancedbracket(std::string)\nisNumber(std::string)\ncheckcount(std::string, char) -> counts instances of char in string\nCheckSubdivision(std::vector<std::vector<std::string>> parsedcode, std::unordered_map<std::string, std::string> &idmap, int i, int j, std::unordered_map<std::string, std::string> shapemap)\nCheckInstance(std::vector<std::vector<std::string>> parsedcode, std::unordered_map<std::string, std::string> &idmap, int i, int j, std::unordered_map<std::string, std::string> shapemap)\nCheckBank(std::vector<std::vector<std::string>> parsedcode, std::unordered_map<std::string, std::string> &referencemap, std::unordered_map<std::string, std::string> &idmap, int i, int j, std::unordered_map<std::string, std::string> shapemap)\nCheckGroup(std::vector<std::vector<std::string>> parsedcode, std::unordered_map<std::string, std::string> &idmap, int i, int j, std::unordered_map<std::string, std::string> shapemap)\n")),(0,o.kt)("p",null,"In your function, you should be checking for "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Correct Number of phrases"),(0,o.kt)("li",{parentName:"ul"},"Valid IDs (use idmap) "),(0,o.kt)("li",{parentName:"ul"},"Appropriate use of optional phrases"),(0,o.kt)("li",{parentName:"ul"},"No reserved characters"),(0,o.kt)("li",{parentName:"ul"},"No illegal phrases (only expected ones)"),(0,o.kt)("li",{parentName:"ul"},"Balanced Brackets")))}u.isMDXComponent=!0}}]);